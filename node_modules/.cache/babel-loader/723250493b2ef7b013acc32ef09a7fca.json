{"ast":null,"code":"export default \"import React, { useCallback, useState } from \\\"react\\\";\\nimport random from \\\"lodash/random\\\";\\nimport { MdAdd } from \\\"react-icons/md\\\";\\n\\n// this function creates a random string of variable characters and variable length\\nconst stringGenerator = (str, tlen) => {\\n  const arr = [...str];\\n  const max = arr.length - 1;\\n  let string = \\\"\\\";\\n  for (let i = 0; i < tlen; i += 1) {\\n    const int = random(max);\\n    string += arr[int];\\n  }\\n  return string;\\n};\\n\\n// this creates a random string with [Aa-Zz,0-9,$/.] that is 8 characters long\\n// NOTE: You can use an alternative approach such as the \\\"uuid\\\" npm package if \\n// you don't want to handle this logic.\\nconst createRandomString = () =>\\n  stringGenerator(\\n    \\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$/.\\\",\\n    8\\n  );\\n\\n// create a custom useDynamicFieldHandler hook that returns values and returns 3 \\n// functions: addField, deleteField, and handleChange.\\nconst useDynamicFieldHandler = initialState => {\\n  const [values, updateFields] = useState(initialState);\\n\\n  // the addField function will not receive any parameters. in the updateFields callback\\n  // it'll spread out any previous fields, before adding a new field object with a \\n  // random name (name needs to be unique to avoid naming collisons when updating the field\\n  // via its \\\"name\\\" property), its position (not required), and an empty value. lastly, \\n  // it'll add 1 to the fieldsCount.\\n  const addField = useCallback(() => {\\n    updateFields(prevState => ({\\n      fields: [\\n        ...prevState.fields,\\n        {\\n          name: `Field_${createRandomString()}`,\\n          position: prevState.fieldsCount + 1,\\n          value: \\\"\\\"\\n        }\\n      ],\\n      fieldsCount: prevState.fieldsCount + 1\\n    }));\\n  }, []);\\n\\n  // the deleteField function will receive a \\\"name\\\" parameter from the field's delete \\n  // button onClick handler. then in the updateField's callback, it'll filter the fields \\n  // array comparing each \\\"field.name\\\" to the \\\"name\\\"; if found, it'll remove the object\\n  // from the array, then, it'll map over this filtered array and update each field's \\n  // position. lastly, the fieldsCount will be deducted by 1.\\n  const deleteField = useCallback(name => {\\n    updateFields(prevState => ({\\n      fields: prevState.fields\\n        .filter(field => field.name !== name)\\n        .map((field, key) => ({ ...field, position: key + 1 })),\\n      fieldsCount: prevState.fieldsCount - 1\\n    }));\\n  }, []);\\n\\n  // the handleChange function will first deconstruct e.target.name and\\n  // e.target.value, then in the updateFields callback function, it'll spread out any \\n  // previous state, then map over the fields array comparing the e.target.name with the \\n  // field.name. if the two are a match, it'll update the value; otherwise, it'll just \\n  // return the field.\\n  const handleChange = useCallback(({ target: { name, value } }) => {\\n    updateFields(prevState => ({\\n      ...prevState,\\n      fields: prevState.fields.map((field, key) =>\\n        field.name === name ? { ...field, value } : field\\n      )\\n    }));\\n  }, []);\\n\\n  return {\\n    addField,\\n    deleteField,\\n    values,\\n    handleChange\\n  };\\n};\\n\\n\\n// utilize the custom useDynamicFieldHandler. in addition, include a \\n// handleSubmit function that handles the form when it has been submitted.\\nconst DynamicFieldForm = () => {\\n  const {\\n    addField,\\n    deleteField,\\n    handleChange,\\n    values\\n  } = useDynamicFieldHandler({\\n    fieldsCount: 1,\\n    fields: [\\n      {\\n        name: `Field_${createRandomString()}`,\\n        position: 1,\\n        value: \\\"\\\"\\n      }\\n    ]\\n  });\\n\\n  const handleSubmit = e => {\\n    e.preventDefault();\\n    alert(JSON.stringify(values, null, 4));\\n  };\\n\\n  return (\\n    <form onSubmit={handleSubmit}>\\n      {values.fields.map(({ name, value }, key) => (\\n        <div key={name}>\\n          <input\\n            type=\\\"text\\\"\\n            name={name}\\n            placeholder=\\\"Type something...\\\"\\n            onChange={handleChange}\\n            value={value}\\n          />\\n            {fieldsCount > 1 && (\\n              <Button onClick={() => deleteField(name)}>\\n                <MdClose />\\n              </Button>\\n            )}\\n        </div>\\n      ))}\\n      <button type=\\\"button\\\"><MdAdd/> Add Field</button>\\n      <button type=\\\"submit\\\">Submit</button>\\n    </form>\\n  );\\n};\\n\\nexport default DynamicFieldForm;\\n\";","map":{"version":3,"sources":["/home/m6d/Documents/react-hooks/src/components/Code/Forms/DynamicField.js"],"names":[],"mappings":"AAAA","sourcesContent":["export default `import React, { useCallback, useState } from \"react\";\nimport random from \"lodash/random\";\nimport { MdAdd } from \"react-icons/md\";\n\n// this function creates a random string of variable characters and variable length\nconst stringGenerator = (str, tlen) => {\n  const arr = [...str];\n  const max = arr.length - 1;\n  let string = \"\";\n  for (let i = 0; i < tlen; i += 1) {\n    const int = random(max);\n    string += arr[int];\n  }\n  return string;\n};\n\n// this creates a random string with [Aa-Zz,0-9,$/.] that is 8 characters long\n// NOTE: You can use an alternative approach such as the \"uuid\" npm package if \n// you don't want to handle this logic.\nconst createRandomString = () =>\n  stringGenerator(\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$/.\",\n    8\n  );\n\n// create a custom useDynamicFieldHandler hook that returns values and returns 3 \n// functions: addField, deleteField, and handleChange.\nconst useDynamicFieldHandler = initialState => {\n  const [values, updateFields] = useState(initialState);\n\n  // the addField function will not receive any parameters. in the updateFields callback\n  // it'll spread out any previous fields, before adding a new field object with a \n  // random name (name needs to be unique to avoid naming collisons when updating the field\n  // via its \"name\" property), its position (not required), and an empty value. lastly, \n  // it'll add 1 to the fieldsCount.\n  const addField = useCallback(() => {\n    updateFields(prevState => ({\n      fields: [\n        ...prevState.fields,\n        {\n          name: \\`Field_\\${createRandomString()}\\`,\n          position: prevState.fieldsCount + 1,\n          value: \"\"\n        }\n      ],\n      fieldsCount: prevState.fieldsCount + 1\n    }));\n  }, []);\n\n  // the deleteField function will receive a \"name\" parameter from the field's delete \n  // button onClick handler. then in the updateField's callback, it'll filter the fields \n  // array comparing each \"field.name\" to the \"name\"; if found, it'll remove the object\n  // from the array, then, it'll map over this filtered array and update each field's \n  // position. lastly, the fieldsCount will be deducted by 1.\n  const deleteField = useCallback(name => {\n    updateFields(prevState => ({\n      fields: prevState.fields\n        .filter(field => field.name !== name)\n        .map((field, key) => ({ ...field, position: key + 1 })),\n      fieldsCount: prevState.fieldsCount - 1\n    }));\n  }, []);\n\n  // the handleChange function will first deconstruct e.target.name and\n  // e.target.value, then in the updateFields callback function, it'll spread out any \n  // previous state, then map over the fields array comparing the e.target.name with the \n  // field.name. if the two are a match, it'll update the value; otherwise, it'll just \n  // return the field.\n  const handleChange = useCallback(({ target: { name, value } }) => {\n    updateFields(prevState => ({\n      ...prevState,\n      fields: prevState.fields.map((field, key) =>\n        field.name === name ? { ...field, value } : field\n      )\n    }));\n  }, []);\n\n  return {\n    addField,\n    deleteField,\n    values,\n    handleChange\n  };\n};\n\n\n// utilize the custom useDynamicFieldHandler. in addition, include a \n// handleSubmit function that handles the form when it has been submitted.\nconst DynamicFieldForm = () => {\n  const {\n    addField,\n    deleteField,\n    handleChange,\n    values\n  } = useDynamicFieldHandler({\n    fieldsCount: 1,\n    fields: [\n      {\n        name: \\`Field_\\${createRandomString()}\\`,\n        position: 1,\n        value: \"\"\n      }\n    ]\n  });\n\n  const handleSubmit = e => {\n    e.preventDefault();\n    alert(JSON.stringify(values, null, 4));\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {values.fields.map(({ name, value }, key) => (\n        <div key={name}>\n          <input\n            type=\"text\"\n            name={name}\n            placeholder=\"Type something...\"\n            onChange={handleChange}\n            value={value}\n          />\n            {fieldsCount > 1 && (\n              <Button onClick={() => deleteField(name)}>\n                <MdClose />\n              </Button>\n            )}\n        </div>\n      ))}\n      <button type=\"button\"><MdAdd/> Add Field</button>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n\nexport default DynamicFieldForm;\n`;\n"]},"metadata":{},"sourceType":"module"}