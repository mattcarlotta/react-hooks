{"ast":null,"code":"export default \"import React, { Fragment, useCallback, useState } from \\\"react\\\";\\nimport { render } from \\\"react-dom\\\";\\nimport { Provider, combineReducers, createStore } from 'redux';\\nimport { connect } from 'react-redux;\\nimport { FaBell, FaTrash, FaPaperPlane, FaTimes } from \\\"react-icons/fa\\\";\\n\\n// NOTE: This example covers a lot of logic within one file and ideally\\n// each of these functions/constants/components will be delegated to\\n// separate files: actions, components, containers, reducers, and types.\\n// For ease of reading, these have been grouped into one.\\n\\n// create types that will be used to dispatch an action.\\nconst UPDATE_INPUT = \\\"UPDATE_INPUT\\\";\\nconst RESET_INPUT = \\\"RESET_INPUT\\\";\\nconst SET_MESSAGE = \\\"SET_MESSAGE\\\";\\nconst RESET_MESSAGE = \\\"RESET_MESSAGE\\\";\\n\\n// create 2 actions that return a \\\"type\\\" and a \\\"payload\\\" (if needed)\\n// one to set a message and one to reset it.\\n\\n// setMessage accepts a \\\"message\\\" parameter to be sent to the reducer\\n// as \\\"payload\\\".\\nconst setMessage = message => ({\\n  type: SET_MESSAGE,\\n  payload: message\\n});\\n\\n// resetMessage just returns a type to be sent to the reducer.\\nconst resetMessage = () => ({\\n  type: RESET_MESSAGE\\n});\\n\\n// create a messageReducer to handle the \\\"action\\\", \\\"type\\\" and \\\"payload\\\"\\n// that was returned by one of the message actions above.\\nconst messageReducer = (state = \\\"\\\", { payload, type }) => {\\n  switch (type) {\\n    case RESET_MESSAGE:\\n      // sets state.message = \\\"\\\";\\n      return \\\"\\\";\\n    case SET_MESSAGE:\\n      // sets state.message = payload (\\\"message\\\" returned from \\\"setMessage\\\")\\n      return payload;\\n    default:\\n      // returns default/updated state.message \\n      return state;\\n  }\\n};\\n\\n// create 2 actions that return a \\\"type\\\" and a \\\"payload\\\" (if needed)\\n// one to update the input and one to reset it.\\n\\n// updateInput accepts a \\\"value\\\" parameter to be sent to the reducer\\n// as \\\"payload\\\".\\nexport const updateInput = value => ({\\n  type: types.UPDATE_INPUT,\\n  payload: value\\n});\\n\\n// resetInput just returns a type to be sent to the reducer.\\nexport const resetInput = () => ({\\n  type: types.RESET_INPUT\\n});\\n\\n// create an inputReducer to handle the \\\"action\\\", \\\"type\\\" and \\\"payload\\\"\\n// that was returned by one of the input actions above.\\nconst inputReducer = (state = \\\"\\\", { payload, type }) => {\\n  switch (type) {\\n    case types.UPDATE_INPUT:\\n      // sets state.input = payload (\\\"value\\\" returned from \\\"updateInput\\\")\\n      return payload;\\n    case types.RESET_INPUT:\\n      // sets state.input = \\\"\\\";\\n      return \\\"\\\";\\n    default:\\n      // returns default/updated state.input \\n      return state;\\n  }\\n};\\n\\n// combine all reducers to be used with \\\"store\\\" (defined below)\\n// \\\"combineReducers\\\" comes from redux and accepts an object.\\n// for example: { test: exampleReducer } which stores in redux\\n// as: state.test: value\\nconst reducers = combineReducers({\\n  // stored in redux as \\\"state.input\\\": \\\"value\\\" -- the value that\\n  // will be returned from the \\\"inputReducer\\\" cases.\\n  input: inputReducer,\\n  // stored in redux as \\\"state.message\\\": \\\"value\\\" -- the value that\\n  // will be returned from the \\\"messageReducer\\\" cases.\\n  message: messageReducer\\n});\\n\\n// create a \\\"MessageForm\\\" container component that connects to the redux store\\n// \\\"MessageForm\\\" and accepts an \\\"inputValue\\\" (state.input) and dispatchable \\n// redux actions: \\\"resetInput\\\", \\\"setMessage\\\", and \\\"updateInput\\\".\\nlet MessageForm = ({ inputValue, resetInput, setMessage, updateInput }) => {\\n  // when the input has been changed, retrieve the \\\"event.target.value\\\" and\\n  // update the \\\"inputValue\\\" (state.input) via \\\"updateInput\\\" redux action.\\n  const handleChange = useCallback(\\n    ({ target: { value } }) => {\\n      updateInput(value);\\n    },\\n    [updateInput]\\n  );\\n\\n  // when the form has been submitted, if there's an \\\"inputValue\\\", dispatch\\n  // \\\"setMessage\\\" with the input's \\\"value\\\" to update \\\"state.message\\\".\\n  const handleSubmit = useCallback(\\n    e => {\\n      e.preventDefault();\\n      if (inputValue) {\\n        setMessage(inputValue);\\n        resetInput();\\n      }\\n    },\\n    [inputValue, resetInput, setMessage]\\n  );\\n\\n  return (\\n    <Fragment>\\n      <form onSubmit={handleSubmit}>\\n        <label htmlFor=\\\"example\\\">Message:</label>\\n        <input\\n          type=\\\"text\\\"\\n          name=\\\"example\\\"\\n          placeholder=\\\"Add a message...\\\"\\n          onChange={handleChange}\\n          value={inputValue}\\n        />\\n        <button type=\\\"button\\\" onClick={resetInput}>\\n          <FaTrash />\\n        </button>\\n        <button type=\\\"submit\\\">\\n          <FaPaperPlane /> Dispatch Message\\n        </button>\\n      </form>\\n    </Fragment>\\n  );\\n};\\n\\n// connect to the redux store to retrieve \\\"state.input\\\" and \\n// prepend \\\"resetInput\\\", \\\"setMessage\\\", and \\\"updateInput\\\" as \\n// redux dispatchable actions.\\nMessageForm = connect(\\n  state => ({ inputValue: state.input }),\\n  { resetInput, setMessage, updateInput }\\n)(MessageForm);\\n\\n// create a \\\"Message\\\" container component that connects to redux and \\n// displays what's currently set in redux's \\\"state.message\\\". the \\n// component accepts \\\"message\\\" (state.message) and a dispatchable\\n// \\\"resetMessage\\\" action.\\nlet Message = ({ message, resetMessage }) => (\\n  message \\n    ? <div>\\n        <div>\\n          <FaBell />\\n          {message}\\n        </div>\\n        <button onClick={resetMessage}>\\n          <FaTimes />\\n        </button>\\n      </div>\\n    : null\\n);\\n\\n// connect to the redux store to retrieve \\\"state.message\\\" and\\n// prepend \\\"resetMessage\\\" as a redux dispatchable action.\\nMessage = connect(\\n  state => ({ message: state.message }),\\n  { resetMessage }\\n)(Message);\\n\\n// create a store for the react-redux \\\"Provider\\\" higher order component\\n// to utilize.\\n// \\\"createStore\\\" comes from redux and accepts the combined \\\"reducers\\\" \\n// defined above.\\nconst store = createStore(reducers);\\n\\n// create an \\\"App\\\" component that wraps the \\\"Message\\\" and \\\"MessageForm\\\" \\n// components with react-redux's \\\"Provider\\\" component. \\n// the \\\"Provider\\\" component requires a \\\"store\\\" that contains all the \\n// \\\"reducers\\\". the \\\"Provider\\\" must be root level; that way, it always \\n// stays mounted despite its children changing.\\nconst App = () => (\\n  <Provider store={store}>\\n    <Message />\\n    <MessageForm />\\n  </Provider>\\n);\\n\\n// render the \\\"App\\\" component defined above.\\nrender(<App />, document.getElementById(\\\"root\\\"));\\n\";","map":{"version":3,"sources":["/home/m6d/Documents/react-hooks/src/components/Code/Misc/Redux.js"],"names":[],"mappings":"AAAA","sourcesContent":["export default `import React, { Fragment, useCallback, useState } from \"react\";\nimport { render } from \"react-dom\";\nimport { Provider, combineReducers, createStore } from 'redux';\nimport { connect } from 'react-redux;\nimport { FaBell, FaTrash, FaPaperPlane, FaTimes } from \"react-icons/fa\";\n\n// NOTE: This example covers a lot of logic within one file and ideally\n// each of these functions/constants/components will be delegated to\n// separate files: actions, components, containers, reducers, and types.\n// For ease of reading, these have been grouped into one.\n\n// create types that will be used to dispatch an action.\nconst UPDATE_INPUT = \"UPDATE_INPUT\";\nconst RESET_INPUT = \"RESET_INPUT\";\nconst SET_MESSAGE = \"SET_MESSAGE\";\nconst RESET_MESSAGE = \"RESET_MESSAGE\";\n\n// create 2 actions that return a \"type\" and a \"payload\" (if needed)\n// one to set a message and one to reset it.\n\n// setMessage accepts a \"message\" parameter to be sent to the reducer\n// as \"payload\".\nconst setMessage = message => ({\n  type: SET_MESSAGE,\n  payload: message\n});\n\n// resetMessage just returns a type to be sent to the reducer.\nconst resetMessage = () => ({\n  type: RESET_MESSAGE\n});\n\n// create a messageReducer to handle the \"action\", \"type\" and \"payload\"\n// that was returned by one of the message actions above.\nconst messageReducer = (state = \"\", { payload, type }) => {\n  switch (type) {\n    case RESET_MESSAGE:\n      // sets state.message = \"\";\n      return \"\";\n    case SET_MESSAGE:\n      // sets state.message = payload (\"message\" returned from \"setMessage\")\n      return payload;\n    default:\n      // returns default/updated state.message \n      return state;\n  }\n};\n\n// create 2 actions that return a \"type\" and a \"payload\" (if needed)\n// one to update the input and one to reset it.\n\n// updateInput accepts a \"value\" parameter to be sent to the reducer\n// as \"payload\".\nexport const updateInput = value => ({\n  type: types.UPDATE_INPUT,\n  payload: value\n});\n\n// resetInput just returns a type to be sent to the reducer.\nexport const resetInput = () => ({\n  type: types.RESET_INPUT\n});\n\n// create an inputReducer to handle the \"action\", \"type\" and \"payload\"\n// that was returned by one of the input actions above.\nconst inputReducer = (state = \"\", { payload, type }) => {\n  switch (type) {\n    case types.UPDATE_INPUT:\n      // sets state.input = payload (\"value\" returned from \"updateInput\")\n      return payload;\n    case types.RESET_INPUT:\n      // sets state.input = \"\";\n      return \"\";\n    default:\n      // returns default/updated state.input \n      return state;\n  }\n};\n\n// combine all reducers to be used with \"store\" (defined below)\n// \"combineReducers\" comes from redux and accepts an object.\n// for example: { test: exampleReducer } which stores in redux\n// as: state.test: value\nconst reducers = combineReducers({\n  // stored in redux as \"state.input\": \"value\" -- the value that\n  // will be returned from the \"inputReducer\" cases.\n  input: inputReducer,\n  // stored in redux as \"state.message\": \"value\" -- the value that\n  // will be returned from the \"messageReducer\" cases.\n  message: messageReducer\n});\n\n// create a \"MessageForm\" container component that connects to the redux store\n// \"MessageForm\" and accepts an \"inputValue\" (state.input) and dispatchable \n// redux actions: \"resetInput\", \"setMessage\", and \"updateInput\".\nlet MessageForm = ({ inputValue, resetInput, setMessage, updateInput }) => {\n  // when the input has been changed, retrieve the \"event.target.value\" and\n  // update the \"inputValue\" (state.input) via \"updateInput\" redux action.\n  const handleChange = useCallback(\n    ({ target: { value } }) => {\n      updateInput(value);\n    },\n    [updateInput]\n  );\n\n  // when the form has been submitted, if there's an \"inputValue\", dispatch\n  // \"setMessage\" with the input's \"value\" to update \"state.message\".\n  const handleSubmit = useCallback(\n    e => {\n      e.preventDefault();\n      if (inputValue) {\n        setMessage(inputValue);\n        resetInput();\n      }\n    },\n    [inputValue, resetInput, setMessage]\n  );\n\n  return (\n    <Fragment>\n      <form onSubmit={handleSubmit}>\n        <label htmlFor=\"example\">Message:</label>\n        <input\n          type=\"text\"\n          name=\"example\"\n          placeholder=\"Add a message...\"\n          onChange={handleChange}\n          value={inputValue}\n        />\n        <button type=\"button\" onClick={resetInput}>\n          <FaTrash />\n        </button>\n        <button type=\"submit\">\n          <FaPaperPlane /> Dispatch Message\n        </button>\n      </form>\n    </Fragment>\n  );\n};\n\n// connect to the redux store to retrieve \"state.input\" and \n// prepend \"resetInput\", \"setMessage\", and \"updateInput\" as \n// redux dispatchable actions.\nMessageForm = connect(\n  state => ({ inputValue: state.input }),\n  { resetInput, setMessage, updateInput }\n)(MessageForm);\n\n// create a \"Message\" container component that connects to redux and \n// displays what's currently set in redux's \"state.message\". the \n// component accepts \"message\" (state.message) and a dispatchable\n// \"resetMessage\" action.\nlet Message = ({ message, resetMessage }) => (\n  message \n    ? <div>\n        <div>\n          <FaBell />\n          {message}\n        </div>\n        <button onClick={resetMessage}>\n          <FaTimes />\n        </button>\n      </div>\n    : null\n);\n\n// connect to the redux store to retrieve \"state.message\" and\n// prepend \"resetMessage\" as a redux dispatchable action.\nMessage = connect(\n  state => ({ message: state.message }),\n  { resetMessage }\n)(Message);\n\n// create a store for the react-redux \"Provider\" higher order component\n// to utilize.\n// \"createStore\" comes from redux and accepts the combined \"reducers\" \n// defined above.\nconst store = createStore(reducers);\n\n// create an \"App\" component that wraps the \"Message\" and \"MessageForm\" \n// components with react-redux's \"Provider\" component. \n// the \"Provider\" component requires a \"store\" that contains all the \n// \"reducers\". the \"Provider\" must be root level; that way, it always \n// stays mounted despite its children changing.\nconst App = () => (\n  <Provider store={store}>\n    <Message />\n    <MessageForm />\n  </Provider>\n);\n\n// render the \"App\" component defined above.\nrender(<App />, document.getElementById(\"root\"));\n`;\n"]},"metadata":{},"sourceType":"module"}