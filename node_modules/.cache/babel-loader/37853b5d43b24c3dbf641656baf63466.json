{"ast":null,"code":"export default \"import React, { Fragment, useState, useCallback } from \\\"react\\\";\\nimport { DragDropContext, Droppable, Draggable } from \\\"react-beautiful-dnd\\\";\\nimport { FaThumbtack } from \\\"react-icons/fa\\\";\\n\\n// initial task data\\nconst initialData = {\\n  tasks: {\\n    \\\"task-1\\\": { \\n      id: \\\"task-1\\\", \\n      description: \\\"Create an upload microservice.\\\" \\n    },\\n    \\\"task-2\\\": {\\n      id: \\\"task-2\\\",\\n      description: \\\"Add top-level notifications.\\\"\\n    },\\n  },\\n  columns: {\\n    \\\"column-1\\\": {\\n      id: \\\"column-1\\\",\\n      title: \\\"To Do\\\",\\n      taskIds: [\\\"task-1\\\"]\\n    },\\n    \\\"column-2\\\": {\\n      id: \\\"column-2\\\",\\n      title: \\\"Completed\\\",\\n      taskIds: [\\\"task-2\\\"]\\n    }\\n  }\\n};\\n\\n// create a custom useDragDropHandler hook that returns values, handles\\n// dragging and dropping, and resetting back to initial state.\\nconst useDragDropHandler = initialState => {\\n  const [values, setValues] = useState(initialState);\\n  const handleChange = useCallback(({ destination, source, draggableId }) => {\\n    if (destination && source) {\\n      setValues(prevState => {\\n        const sourceIndex = source.index; // source taskId index\\n        const destinationIndex = destination.index; // destination taskId index\\n        const sourceContainer = prevState.columns[source.droppableId]; // source container object\\n        const destinationContainer = prevState.columns[destination.droppableId]; // desination container object\\n        const sourceIds = Array.from(sourceContainer.taskIds); // source container \\\"taskIds\\\" array\\n        const destinationIds = Array.from(destinationContainer.taskIds); // destination container \\\"taskIds\\\" array\\n        const isSameContainer = sourceContainer === destinationContainer; // check if source and destination container are the same\\n\\n        // remove a taskId from the source \\\"taskIds\\\" array via the sourceIndex\\n        sourceIds.splice(sourceIndex, 1); \\n\\n        // add a taskId (draggableId) to the source or destination \\\"taskIds\\\" array \\n        if (isSameContainer) {\\n          sourceIds.splice(destinationIndex, 0, draggableId);\\n        } else {\\n          destinationIds.splice(destinationIndex, 0, draggableId);\\n        }\\n\\n        // update the source container with changed sourceIds\\n        const newSourceContainer = {\\n          ...sourceContainer,\\n          taskIds: sourceIds\\n        };\\n\\n        // update the destination container with changed destinationIds\\n        const newDestinationContainer = {\\n          ...destinationContainer,\\n          taskIds: destinationIds\\n        };\\n\\n        // if the source and destination container are the same\\n        // update the source container only, otherwise, update both\\n        const updatedColumns = isSameContainer\\n          ? { [newSourceContainer.id]: newSourceContainer }\\n          : {\\n              [newSourceContainer.id]: newSourceContainer,\\n              [newDestinationContainer.id]: newDestinationContainer\\n            };\\n\\n        return {\\n          ...prevState,\\n          columns: {\\n            ...prevState.columns,\\n            ...updatedColumns\\n          }\\n        };\\n      });\\n    }\\n  }, []);\\n\\n  const resetValues = useCallback(() => setValues(initialState), [\\n    initialState\\n  ]);\\n\\n  return {\\n    values,\\n    handleChange,\\n    resetValues\\n  };\\n};\\n\\n// create a reusable \\\"DragDrop\\\" component that takes in\\n// tasks, columns and a handleChange function\\nconst DragDrop = ({ tasks, columns, handleChange }) => (\\n  <DragDropContext onDragEnd={handleChange}>\\n    {Object.values(columns).map(({ id, title, taskIds }) => (\\n      <Droppable key={id} droppableId={droppableId}>\\n        {({ innerRef, droppableProps, placeholder }) => (\\n          <div\\n            ref={innerRef}\\n            {...droppableProps}\\n          >\\n            <h5>{title}</h5>\\n            {taskIds && taskIds.length > 0 \\n              ? taskIds.map((task, index) => (\\n                  <Draggable key={task.id} draggableId={task.id} index={index}>\\n                     {({ draggableProps, dragHandleProps, innerRef }) => (\\n                        <div ref={innerRef} {...draggableProps} {...dragHandleProps}>\\n                          <div>\\n                            {task.description}\\n                          </div>\\n                        </div>\\n                      )}\\n                  </Draggable>\\n                ))\\n              : <div>\\n                  <FaThumbtack />\\n                  <br />\\n                  No Tasks\\n                </div>\\n            )}\\n            {placeholder}\\n          </div>\\n        )}\\n      </Droppable>\\n    ))}\\n  </DragDropContext>\\n);\\n\\n// utilize the custom useDragDropHandler hook and the \\\"DragDrop\\\" reuseable component\\n// within a function.\\nconst DragDropExample = () => {\\n  const { values, handleChange, resetValues } = useDragDropHandler(initialData);\\n\\n  return (\\n    <Fragment>      \\n      <DragDrop\\n        columns={values.columns}\\n        tasks={values.tasks}\\n        handleChange={handleChange}\\n      />\\n      <button onClick={resetValues}>\\n        Reset\\n      </button>\\n    </Fragment>\\n  );\\n};\\n\\nexport default DragDropExample;\\n\";","map":{"version":3,"sources":["/home/m6d/Documents/react-hooks/src/components/Code/Misc/DragNDrop.js"],"names":[],"mappings":"AAAA","sourcesContent":["export default `import React, { Fragment, useState, useCallback } from \"react\";\nimport { DragDropContext, Droppable, Draggable } from \"react-beautiful-dnd\";\nimport { FaThumbtack } from \"react-icons/fa\";\n\n// initial task data\nconst initialData = {\n  tasks: {\n    \"task-1\": { \n      id: \"task-1\", \n      description: \"Create an upload microservice.\" \n    },\n    \"task-2\": {\n      id: \"task-2\",\n      description: \"Add top-level notifications.\"\n    },\n  },\n  columns: {\n    \"column-1\": {\n      id: \"column-1\",\n      title: \"To Do\",\n      taskIds: [\"task-1\"]\n    },\n    \"column-2\": {\n      id: \"column-2\",\n      title: \"Completed\",\n      taskIds: [\"task-2\"]\n    }\n  }\n};\n\n// create a custom useDragDropHandler hook that returns values, handles\n// dragging and dropping, and resetting back to initial state.\nconst useDragDropHandler = initialState => {\n  const [values, setValues] = useState(initialState);\n  const handleChange = useCallback(({ destination, source, draggableId }) => {\n    if (destination && source) {\n      setValues(prevState => {\n        const sourceIndex = source.index; // source taskId index\n        const destinationIndex = destination.index; // destination taskId index\n        const sourceContainer = prevState.columns[source.droppableId]; // source container object\n        const destinationContainer = prevState.columns[destination.droppableId]; // desination container object\n        const sourceIds = Array.from(sourceContainer.taskIds); // source container \"taskIds\" array\n        const destinationIds = Array.from(destinationContainer.taskIds); // destination container \"taskIds\" array\n        const isSameContainer = sourceContainer === destinationContainer; // check if source and destination container are the same\n\n        // remove a taskId from the source \"taskIds\" array via the sourceIndex\n        sourceIds.splice(sourceIndex, 1); \n\n        // add a taskId (draggableId) to the source or destination \"taskIds\" array \n        if (isSameContainer) {\n          sourceIds.splice(destinationIndex, 0, draggableId);\n        } else {\n          destinationIds.splice(destinationIndex, 0, draggableId);\n        }\n\n        // update the source container with changed sourceIds\n        const newSourceContainer = {\n          ...sourceContainer,\n          taskIds: sourceIds\n        };\n\n        // update the destination container with changed destinationIds\n        const newDestinationContainer = {\n          ...destinationContainer,\n          taskIds: destinationIds\n        };\n\n        // if the source and destination container are the same\n        // update the source container only, otherwise, update both\n        const updatedColumns = isSameContainer\n          ? { [newSourceContainer.id]: newSourceContainer }\n          : {\n              [newSourceContainer.id]: newSourceContainer,\n              [newDestinationContainer.id]: newDestinationContainer\n            };\n\n        return {\n          ...prevState,\n          columns: {\n            ...prevState.columns,\n            ...updatedColumns\n          }\n        };\n      });\n    }\n  }, []);\n\n  const resetValues = useCallback(() => setValues(initialState), [\n    initialState\n  ]);\n\n  return {\n    values,\n    handleChange,\n    resetValues\n  };\n};\n\n// create a reusable \"DragDrop\" component that takes in\n// tasks, columns and a handleChange function\nconst DragDrop = ({ tasks, columns, handleChange }) => (\n  <DragDropContext onDragEnd={handleChange}>\n    {Object.values(columns).map(({ id, title, taskIds }) => (\n      <Droppable key={id} droppableId={droppableId}>\n        {({ innerRef, droppableProps, placeholder }) => (\n          <div\n            ref={innerRef}\n            {...droppableProps}\n          >\n            <h5>{title}</h5>\n            {taskIds && taskIds.length > 0 \n              ? taskIds.map((task, index) => (\n                  <Draggable key={task.id} draggableId={task.id} index={index}>\n                     {({ draggableProps, dragHandleProps, innerRef }) => (\n                        <div ref={innerRef} {...draggableProps} {...dragHandleProps}>\n                          <div>\n                            {task.description}\n                          </div>\n                        </div>\n                      )}\n                  </Draggable>\n                ))\n              : <div>\n                  <FaThumbtack />\n                  <br />\n                  No Tasks\n                </div>\n            )}\n            {placeholder}\n          </div>\n        )}\n      </Droppable>\n    ))}\n  </DragDropContext>\n);\n\n// utilize the custom useDragDropHandler hook and the \"DragDrop\" reuseable component\n// within a function.\nconst DragDropExample = () => {\n  const { values, handleChange, resetValues } = useDragDropHandler(initialData);\n\n  return (\n    <Fragment>      \n      <DragDrop\n        columns={values.columns}\n        tasks={values.tasks}\n        handleChange={handleChange}\n      />\n      <button onClick={resetValues}>\n        Reset\n      </button>\n    </Fragment>\n  );\n};\n\nexport default DragDropExample;\n`;\n"]},"metadata":{},"sourceType":"module"}